#include "vtkSurfaceReconstructionFilter.h"
#include "vtkProgrammableSource.h"
#include "vtkContourFilter.h"
#include "vtkReverseSense.h"
#include "vtkPolyDataMapper.h"
#include "vtkProperty.h"
#include "vtkCamera.h"
#include "vtkRenderer.h"
#include "vtkRenderWindow.h"
#include "vtkRenderWindowInteractor.h"
#include <vtkMath.h>
#include <cmath>


void readPoints(void*);

int main(int argc, char **argv)

{

   // Read some points. Use a programmable filter to read them.
	vtkProgrammableSource* pointSource = vtkProgrammableSource::New();
	void (*f)(void*) = readPoints;
	pointSource->SetExecuteMethod(f, pointSource);

	// Construct the surface and create isosurface.	
	vtkSurfaceReconstructionFilter* surf = vtkSurfaceReconstructionFilter::New();
	surf->SetInputConnection(pointSource->GetOutputPort());

	vtkContourFilter* cf = vtkContourFilter::New();
	cf->SetInputConnection(surf->GetOutputPort());
	cf->SetValue(0, 0.0);

	// Sometimes the contouring algorithm can create a volume whose gradient
	// vector and ordering of polygon (using the right hand rule) are
	// inconsistent. vtkReverseSense cures this problem.
	vtkReverseSense* reverse = vtkReverseSense::New();
	reverse->SetInputConnection(cf->GetOutputPort());
	reverse->ReverseCellsOn();
	reverse->ReverseNormalsOn();

	vtkPolyDataMapper* map = vtkPolyDataMapper::New();
	map->SetInputConnection(reverse->GetOutputPort());
	map->ScalarVisibilityOff();

	vtkActor* surfaceActor = vtkActor::New();
	surfaceActor->SetMapper(map);
	surfaceActor->GetProperty()->SetDiffuseColor(1.0000, 0.3882, 0.2784);
	surfaceActor->GetProperty()->SetSpecularColor(1, 1, 1);
	surfaceActor->GetProperty()->SetSpecular(.4);
	surfaceActor->GetProperty()->SetSpecularPower(50);

	// Create the RenderWindow, Renderer and both Actors
	vtkRenderer* ren = vtkRenderer::New();
	vtkRenderWindow* renWin = vtkRenderWindow::New();
	renWin->AddRenderer(ren);
	vtkRenderWindowInteractor* iren = vtkRenderWindowInteractor::New();
	iren->SetRenderWindow(renWin);

	// Add the actors to the renderer, set the background and size
	ren->AddActor(surfaceActor);
	ren->SetBackground(1, 1, 1);
	renWin->SetSize(400, 400);
	ren->GetActiveCamera()->SetFocalPoint(0, 0, 0);
	ren->GetActiveCamera()->SetPosition(1, 0, 0);
	ren->GetActiveCamera()->SetViewUp(0, 0, 1);
	ren->ResetCamera();
	ren->GetActiveCamera()->Azimuth(20);
	ren->GetActiveCamera()->Elevation(30);
	ren->GetActiveCamera()->Dolly(1.2);
	ren->ResetCameraClippingRange();

	iren->Initialize();
	renWin->Render();
	iren->Start();

	return 0;

}



void readPoints(void *ps)
{
	vtkProgrammableSource* pointSource = (vtkProgrammableSource*)ps;
	//vtkPolyData* output = vtkPolyData::New();
	vtkPolyData *output = pointSource->GetPolyDataOutput();

	vtkPoints* points = vtkPoints::New();
	output->SetPoints(points);

	float x, y, z;
	// generate random points on unit sphere
	for(int i=0; i<100; i++) {
		double phi, theta,u,v;
		u = vtkMath::Random(0.0,1.0);
		v = vtkMath::Random(0.0,1.0);
		phi = 2.0*3.14159265*u;
		theta = acos(2.0*v-1.0);

		x = std::cos(phi)*std::sin(theta);
		y = std::sin(phi)*std::sin(theta);
		z = std::cos(theta);


		points->InsertNextPoint(x, y, z);
	}
	return;
}
