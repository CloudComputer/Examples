#include <vtkCellData.h>
#include <vtkCellArray.h>
#include <vtkDoubleArray.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkPointData.h>
#include <vtkSmartPointer.h>
#include <vtkXMLPolyDataReader.h>
#include <vtkPolyDataNormals.h>

#include <iostream>
#include <string>
#include <vector>

struct Point
{
	double x,y,z;
};

struct Vector
{
	double x,y,z;
};

//std::vector<Vector> GetNormalsFromPolydata(vtkPolyData* polydata);
std::vector<Vector> GetNormalsFromPolydata(vtkSmartPointer<vtkPolyData> polydata);

//bool ConstructFromPolydata(vtkPolyData* polydata);
bool ConstructFromPolydata(vtkSmartPointer<vtkPolyData> polydata);

bool VtpRead(const std::string &filename);

//bool HasScannerLocation(vtkPolyData* polydata);
bool HasScannerLocation(vtkSmartPointer<vtkPolyData> polydata);


int main(int argc, char *argv[])
{
	//Read File
	std::string filename = argv[1]; //first command line argument
	
	bool ReadSuccess = VtpRead(filename);
	
	return 0;
}

bool VtpRead(const std::string &filename)
{
	//get all data from the file
	vtkSmartPointer<vtkXMLPolyDataReader> reader = vtkSmartPointer<vtkXMLPolyDataReader>::New();
	cout << "Reading " << filename << endl;
	reader->SetFileName(filename.c_str());
	reader->Update();
	
	vtkSmartPointer<vtkPolyData> polydata = reader->GetOutput();

	ConstructFromPolydata(polydata);
	
	return true;
}


//bool ConstructFromPolydata(vtkPolyData* polydata)
bool ConstructFromPolydata(vtkSmartPointer<vtkPolyData> polydata)
{
	//get points
	vtkIdType idNumPointsInFile = polydata->GetNumberOfPoints();
	unsigned int NumPointsInFile = static_cast<unsigned int> (idNumPointsInFile);
	
	if(!(NumPointsInFile > 0) )
	{
		return false;
	}
	
	std::vector<Point> Points_(NumPointsInFile);
	
	double point[3];
	for(unsigned int i = 0; i < NumPointsInFile; i++)
	{
		polydata->GetPoint(i, point);
		Point P;
		P.x = point[0]; P.y = point[1]; P.z = point[2];
		Points_.push_back(P);
	}
	
	//get triangles
	std::vector<std::vector<unsigned int> > VertexLists_;
	vtkIdType NumPolys = polydata->GetNumberOfPolys();
	if(NumPolys > 0)
	{
		vtkSmartPointer<vtkCellArray> TriangleCells = polydata->GetPolys();
		vtkIdType npts;
		vtkIdType *pts;

		while(TriangleCells->GetNextCell(npts, pts))
		{
			std::vector<unsigned int> List(3);
			List[0] = pts[0];
			List[1] = pts[1];
			List[2] = pts[2];
			
			VertexLists_.push_back(List);
		}	
		
	}
	
	cout << "Has Scanner location: " << HasScannerLocation(polydata) << endl;
	
	//get normals
	std::vector<Vector> Normals = GetNormalsFromPolydata(polydata);
	if(Normals.size() == NumPointsInFile)
	{
		cout << "Normals found on first pass. There are " << Normals.size() << " of them." << endl;
	}
	else
	{
		//if none of the normal types we looked for exist, then create them from the cells
		cout << "Normals NOT found on first pass, extracting..." << endl;
		cerr << "Number of points before normal extraction: " << polydata->GetNumberOfPoints() << endl;
		vtkSmartPointer<vtkPolyDataNormals> normalGenerator = vtkSmartPointer<vtkPolyDataNormals>::New();
		normalGenerator->SetInput(polydata);
		normalGenerator->Update();
		polydata = normalGenerator->GetOutput();
		Normals = GetNormalsFromPolydata(polydata);
		cout << "There were " << Normals.size() << " normals extracted." << endl;
		//cerr << "Number of points after normal extraction: " << polydata->GetNumberOfPoints() << endl;
		//we should be confident that polydata is still in good shape here...
	}
	
	cout << "Has Scanner location: " << HasScannerLocation(polydata) << endl;
	
}

//std::vector<Vector> GetNormalsFromPolydata(vtkPolyData* polydata)
std::vector<Vector> GetNormalsFromPolydata(vtkSmartPointer<vtkPolyData> polydata)
{
	std::vector<Vector> Normals;
	cout << "Getting normals...." << endl;
	
	//normals in an array
	vtkSmartPointer<vtkDoubleArray> NormalData1 = vtkDoubleArray::SafeDownCast(polydata->GetPointData()->GetArray("Normals"));
	
	if(NormalData1)
	{ 
		unsigned int nNormals1 = polydata->GetPointData()->GetArray("Normals")->GetNumberOfTuples();
		double normal[3];
		
		for(unsigned int i = 0; i < nNormals1; i++)
		{
			NormalData1->GetTupleValue(i, normal);
			Vector N;
			N.x = normal[0];
			N.y = normal[1];
			N.z = normal[2];
			Normals.push_back(N);
		}
		return Normals;
	}
		
	//actual point normals
	vtkSmartPointer<vtkDataArray> PointNormals = polydata->GetPointData()->GetNormals();
	
	if(PointNormals)
	{
		
		Normals.clear();
		double normal[3];
		
		for(unsigned int i = 0; i < PointNormals->GetNumberOfTuples(); i++)
		{
			//NormalData2->GetTupleValue(i, normal);
			PointNormals->GetTuple(i, normal);
			Vector N;
			N.x = normal[0]; N.y = normal[1]; N.z = normal[2];
			Normals.push_back(N);
		}
		return Normals;
	}
	
	
	//double normals
	vtkSmartPointer<vtkDataArray> CellNormals = polydata->GetCellData()->GetNormals("cellNormals");
	
	if(CellNormals)
	{
		double normal[3];
		
		for(unsigned int i = 0; i < CellNormals->GetNumberOfTuples(); i++)
		{
			CellNormals->GetTuple(i, normal);
			Vector N;
			N.x = normal[0]; N.y = normal[1]; N.z = normal[2];
			Normals.push_back(N);
		}

		return Normals;
	}
	
	cout << "There are " << Normals.size() << " Normals." << endl;
	
	return Normals;
}

//bool HasScannerLocation(vtkPolyData* polydata)
bool HasScannerLocation(vtkSmartPointer<vtkPolyData> polydata)
{
	//get scanner location
	cout << "Getting scanner location..." << endl;
	vtkSmartPointer<vtkDataArray> ScannerLocationVTKArray;
	vtkFieldData* FieldData = polydata->GetFieldData();
	
	if(FieldData)
		ScannerLocationVTKArray = FieldData->GetArray("ScannerLocation");
	
	if(ScannerLocationVTKArray)
	{
		return true;
	}
	
	return false;
}